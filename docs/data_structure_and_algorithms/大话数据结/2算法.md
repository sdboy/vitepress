---
lang: zh-CN
title: 数据结构
titleTemplate: 算法
description: 大话数据结构
head:
  - - meta
    - name: description
      content: 大话数据结构
  - - meta
    - name: keywords
      content: data structure 数据结构 SEO
layout: doc
navbar: true
sidebar: true
aside: true
outline: deep
lastUpdated: Date
editLink: true
footer: true
---
# 2 算法

## 2.4 算法的定义

算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。<br。

## 2.5 算法的特性
算法有五个基本特性：输入、输出、有穷性、确定性、可行性。<br>

### 2.5.1 输入、输出

算法具有零个或多个输入。算法至少有一个或多个输出。

### 2.5.2 有穷性

有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。<br>

### 2.5.3 确定性

确定性：算法的每一步骤都具有确定的含义，不会出现二义性。<br>

### 2.5.4 可行性

可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。<br>

## 2.6 算法设计的要求

正确性、可读性、健壮性、时间效率高和存储量低。<br>

### 2.6.1 正确性

算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性，能正确反应问题的需求，能够得到问题的正确答案。<br>

大体分为四个层次：
- 算法程序没有语法错误
- 算法程序对于合法的输入数据能够产生满足要求的出结果
- 算法程序对于非法输入数据能够产生错误信息
- 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果

### 2.6.2 可读性

算法设计的另一目的是为了便于阅读、理解和交流。<br>

### 2.6.3 健壮性

当输入不合法数据时，算法能够做出相关处理，而不是发生异常或莫名其妙的结果。<br>

### 2.6.4 时间效率高和存储量低

算法应该尽量满足时间效率高和存储量低的要求。<br>

## 2.7 算法效率的度量方法

### 2.7.1 事后统计法

通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率。<br>
缺陷：
- 花费大量时间和精力
- 比较容易受硬件和软件环境影响
- 算法的测试数据设计困难

这种方法不考虑采纳。<br>

### 2.7.2 事前分析估算法

在程序编制前，依据统计方法队算法进行估量。<br>

程序在计算机上运行消耗的时间主要取决于以下因素：
- 算法采用的策略、方法
- 编译产生的代码质量
- 问题的输入规模
- 机器执行指令的速度

一个程序运行时间，依赖于算法的好坏和问题的输入规模。<br>

## 2.8 函数的渐近增长

给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n)。<br>

判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更因该关注主项（最高阶项）的阶数。<br>

## 2.9 算法时间复杂度

### 2.9.1 时间复杂度定义

在进行算法分析时，语句宗的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况确定T(n)的数量级。算法的时间复杂度也就是算法的时间量度，记作T(n)=**O**(f(n))。他表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。<br>

用大写**O**()来体现算法时间复杂度的记法，我们称为大**O**记法。<br>

### 2.9.2 推导大O阶方法

推导大O阶：
- 用常熟1取代运行时间中的所有加法常数。
- 再修改后的运行次数函数中，只保留最高阶项
- 如果最高阶项存在且系数不是1，则去除与整个项相乘的系数。得到的结果就是大O阶

### 2.9.3 常熟阶

不管这个常量是多少，我们都记作O(1)，而不是O(3)、O(12)等其他任何数字。

### 2.9.4 线性阶

分析算法的复杂度，关键就是要分析循环结构的运行情况。<br>

### 2.9.5 对数阶

```c
int count = 1;
while(count <= n)
{
  count *= 2;
}
```
由2^x = n得到x=log2(n)，得到时间复杂度O(log2n)。

### 2.9.6 平方阶

```c
int i, j;
for(i = 0; i < n; i++)
{
  for(j = i; j < n; j++)
  {
    printf("i=%d, j=%d\n", i, j);
  }
}
```

由于当i=0时，内循环执行了n次，当i=1时，内循环执行n-1次，当i=n-1时执行了1次...以此类推，执行的总次数为：<br>
n+n-1+n-2+...+1+0=n*(n+1)/2<br>
没有常数项，保留最高阶项得到n^2/2，去除常数项系数为O(n^2)。<br>

## 2.10 常见的时间复杂度

|执行次数|阶|非正式术语|
|:---:|:---:|:---:|
|12|O(1)|常熟阶|
|2n+3|O(n)|线性阶|
|3n^2+2n+1|O(n^2)|平方阶|
|5log2(n)+20|O(logn)|对数阶|
|2n+3nlog2(n)+19|O(nlogn)|对数线性阶|
|6n^3+2n^2+3n+4|O(n^3)|立方阶|
|2^n|O(2^n)|指数阶|

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

## 2.11 最坏情况与平均情况

平均运行时间是所有情况中最有意义的，因为他是期望的运行时间。一般在没有特殊说明的情况下，都是指最坏时间复杂度。<br>

## 2.12 算法空间复杂度

算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题规模，f(n)为语句关于n所占存储空间的函数。<br>
